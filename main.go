package main

import (
	"fmt"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/descriptorpb"
	"protoc-gen-go-bnet/bnet"
)

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generateFile(gen, f)
		}
		return nil
	})
}

// generateFile generates a _ascii.pb.go file containing gRPC service definitions.
func generateFile(gen *protogen.Plugin, file *protogen.File) {
	if len(file.Services) > 0 {
		filename := file.GeneratedFilenamePrefix + "_services.pb.go"
		g := gen.NewGeneratedFile(filename, file.GoImportPath)
		g.P("// Code generated by protoc-gen-go-bnet. DO NOT EDIT.")
		g.P()
		g.P("package ", file.GoPackageName)
		g.P()

		g.P("import (")
		g.P("\"context\"")
		g.P("\"strings\"")
		g.P(")")

		generateServiceFile(gen, file, g)
	}

	if len(file.Services) > 0 {
		filename := file.GeneratedFilenamePrefix + "_handler.pb.go"
		g := gen.NewGeneratedFile(filename, file.GoImportPath)
		g.P("// Code generated by protoc-gen-go-bnet. DO NOT EDIT.")
		g.P()
		g.P("package ", file.GoPackageName)
		g.P()

		g.P("import (")
		g.P("\"context\"")
		g.P("\"fmt\"")
		g.P("\"strings\"")
		g.P("\"google.golang.org/protobuf/proto\"")
		g.P(")")

		generateServiceHandlerFile(gen, file, g)
	}
}

func generateServiceFile(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
	for _, service := range file.Services {
		// generate the name hash
		g.P("// ", service.GoName, "Hash is the hash of the service name")
		g.P("const ", service.GoName, "Hash uint32 = ", hashName(string(service.Desc.FullName())), " // ", service.Desc.FullName())

		// If the service has an option for the original name, generate a const for it
		if service.Desc.Options() != nil && service.Desc.Options().ProtoReflect().Has(bnet.E_OriginalFullyQualifiedDescriptorName.TypeDescriptor()) {
			name := service.Desc.Options().ProtoReflect().Get(bnet.E_OriginalFullyQualifiedDescriptorName.TypeDescriptor()).String()
			g.P("// ", service.GoName, "OriginalFullyQualifiedDescriptorName is the original fully qualified descriptor name")
			g.P("const ", service.GoName, "OriginalFullyQualifiedDescriptorName string = \"", name, "\"")

			// const of the hash of the original name
			g.P("// ", service.GoName, "OriginalFullyQualifiedDescriptorNameHash is the hash of the original fully qualified descriptor name")
			g.P("const ", service.GoName, "OriginalFullyQualifiedDescriptorNameHash uint32 = ", hashName(name), " // ", name)

			g.P()
		}

		// Generate the interface
		g.P("// ", service.GoName, " is the client API for ", service.Desc.FullName())
		g.P("type ", service.GoName, " interface {")
		for _, method := range service.Methods {
			// if method.GoName has DEPRECATED in it, add a comment to the method that it is deprecated
			opt, ok := method.Desc.Options().(*descriptorpb.MethodOptions)

			startCommentTest := string(method.Desc.Name())
			if ok {
				if opt.Deprecated != nil && *opt.Deprecated {
					startCommentTest = fmt.Sprintf("Deprecated: %s", startCommentTest)
				}
			}

			name := method.Desc.Options().ProtoReflect().Get(bnet.E_MethodId.TypeDescriptor()).Uint()

			g.P("// ", startCommentTest, " has a method id of ", name, " and a method name of ", method.Desc.FullName())
			g.P(method.GoName, "(context.Context, *", method.Input.GoIdent, ", interface{})  error")
		}
		g.P("}")

		g.P()

		// generate a service.Methods look up map based on the bnet.E_MethodId value
		g.P("// ", service.GoName, "Methods is a map of method ids to method names")
		g.P("var ", service.GoName, "Methods = map[uint32]string{")
		for _, method := range service.Methods {
			if method.Desc.Options() != nil {
				if method.Desc.Options().ProtoReflect().Has(bnet.E_MethodId.TypeDescriptor()) {
					name := method.Desc.Options().ProtoReflect().Get(bnet.E_MethodId.TypeDescriptor()).Uint()
					g.P(name, ": \"", method.Desc.FullName(), "\",")
				}
			} else {
				g.P("// ", method.GoName, " does not have a method id")
			}
		}
		g.P("}")

		g.P()
		g.P("// ", service.GoName, "Method is the method id for ", service.Desc.FullName())
		g.P("type ", service.GoName, "Method uint32")
		g.P()

		g.P("// Enum value maps for ", service.GoName, "Method.")
		g.P("const (")
		for _, method := range service.Methods {
			if method.Desc.Options() != nil {
				if method.Desc.Options().ProtoReflect().Has(bnet.E_MethodId.TypeDescriptor()) {
					name := method.Desc.Options().ProtoReflect().Get(bnet.E_MethodId.TypeDescriptor()).Uint()

					g.P("// ", service.GoName, "Method_", method.GoName, " ", service.GoName, "Method = ", name, " // ", method.Desc.FullName())
					g.P(service.GoName, "Method_", method.GoName, " ", service.GoName, "Method = ", name, " // ", method.Desc.FullName())
				}
			} else {
				g.P("// ", method.GoName, " does not have a method id")
			}
		}
		g.P(")")

		g.P()

		// convert to uint32
		g.P("// ToUint32 converts a ", service.GoName, "Method enum to a uint32")
		g.P("func (m ", service.GoName, "Method) ToUint32() uint32 {")
		g.P("return uint32(m)")
		g.P("}")
		g.P()

		// create a function to get the method name from the method id
		g.P("// GetMethodFullName returns the method full name for the given method id")
		g.P("func (m ", service.GoName, "Method) GetMethodFullName() string {")
		g.P("return ", service.GoName, "Methods[uint32(m)]")
		g.P("}")
		g.P()

		// get the method name from the id (ex: bgs.protocol.authentication.v1.AuthenticationService.Logon) is just "Logon"
		g.P("// GetMethodName returns the method name for the given method id")
		g.P("func (m ", service.GoName, "Method) GetMethodName() string {")
		// check if the method id is in the map
		g.P("if _, ok := ", service.GoName, "Methods[uint32(m)]; !ok {")
		g.P("return \"No Method Exist\"")
		g.P("}")
		g.P("return ", service.GoName, "Methods[uint32(m)][strings.LastIndex(", service.GoName, "Methods[uint32(m)], \".\")+1:]")
		g.P("}")
	}

	g.P()
}

func generateServiceHandlerFile(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
	for _, service := range file.Services {
		g.P("// ", service.GoName, "Handler is the handler interface for ", service.Desc.FullName())
		g.P("type ", service.GoName, "Handler struct {")
		g.P("serviceHash uint32")
		g.P("service ", service.GoName)
		g.P("}")
		g.P()

		g.P("// New", service.GoName, "Handler creates a new ", service.GoName, "Handler")
		g.P("func New", service.GoName, "Handler(service ", service.GoName, ") *", service.GoName, "Handler {")
		g.P("return &", service.GoName, "Handler{")
		g.P("serviceHash: ", service.GoName, "OriginalFullyQualifiedDescriptorNameHash,")
		g.P("service: service,")
		g.P("}")
		g.P("}")
		g.P()

		// generate a method that returns the service hash
		g.P("// GetServiceHash returns the service hash")
		g.P("func (h *", service.GoName, "Handler) GetServiceHash() uint32 {")
		g.P("return h.serviceHash")
		g.P("}")
		g.P()

		g.P("// GetServiceFullName returns the service")
		g.P("func (h *", service.GoName, "Handler) GetServiceFullName() string {")
		g.P("return ", service.GoName, "OriginalFullyQualifiedDescriptorName")
		g.P("}")
		g.P()

		g.P("// GetServiceFullName returns the service")
		g.P("func (h *", service.GoName, "Handler) GetServiceName() string {")
		g.P("return ", service.GoName, "OriginalFullyQualifiedDescriptorName[strings.LastIndex(", service.GoName, "OriginalFullyQualifiedDescriptorName, \".\")+1:]")
		g.P("}")
		g.P()

		g.P("// GetService returns the service")
		g.P("func (h *", service.GoName, "Handler) GetService() ", service.GoName, " {")
		g.P("return h.service")
		g.P("}")

		// generate the handler methods such as call the service by hash and method id
		g.P("// Call calls the service by hash and method id on the handlers service")
		g.P("func (h *", service.GoName, "Handler) Call(ctx context.Context, methodId uint32, body []byte, conn interface{}) error {")

		g.P("switch methodId {")
		for _, method := range service.Methods {
			if method.Desc.Options() != nil {
				if method.Desc.Options().ProtoReflect().Has(bnet.E_MethodId.TypeDescriptor()) {
					name := method.Desc.Options().ProtoReflect().Get(bnet.E_MethodId.TypeDescriptor()).Uint()
					g.P("case ", name, ":")

					if method.Input.Fields != nil && len(method.Input.Fields) > 0 {
						// parse the body into the proper request type
						g.P("var req ", method.Input.GoIdent)
						g.P("if err := proto.Unmarshal(body, &req); err != nil {")
						g.P("return err")
						g.P("}")
						g.P("return h.service.", method.GoName, "(ctx, &req, conn)")
					} else {
						g.P("return h.service.", method.GoName, "(ctx, nil, conn)")
					}
				}
			} else {
				g.P("// ", method.GoName, " does not have a method id")
			}
		}
		g.P("default:")
		g.P("return fmt.Errorf(\"unknown method id %d\", methodId)")
		g.P("}")
		g.P("}")
		g.P()
	}
}

func hashName(name string) uint32 {
	hash := uint32(0x811C9DC5)

	for _, c := range name {
		hash ^= uint32(c)
		hash *= 0x1000193
	}

	return hash
}
